package com.leetcode.bryan;

import com.leetcode.bryan.easy.SumofSquareNumbers;
import com.leetcode.bryan.medium.GraphValidTree;


public class Main {

    public static void main(String[] args) {
    // easy
        //int value = SingleNumber.singleNumber();
        //boolean rlt = ValidParentheses.isValid();
        //int[] result = HowManyNumbersAreSmallerThantheCurrentNumber.smallerNumbersThanCurrent();
        //ExcelSheetColumnTitle e = new ExcelSheetColumnTitle();
        //e.convertToTitle(2147483647);
        //MinStack ms = new MinStack();
        //String s = "iloveleetcode";
        //String words[] = {"app", "i","love","leetcode","apples"};
        //CheckIfStringIsaPrefixofArray c = new CheckIfStringIsaPrefixofArray();
        //boolean rlt = c.isPrefixString(s, words);
        //MinimumTimetoTypeWordUsingSpecialTypewriter m = new MinimumTimetoTypeWordUsingSpecialTypewriter();
        //m.minTimeToType("zjpc");
        SumofSquareNumbers s = new SumofSquareNumbers();
        s.judgeSquareSum(2);

    // medium
        //ContainerWithMostWater.maxArea();
        //ValidSquare.validSquare();
        //SortColors.sortColors();
        //String out = DecodeString.decodeString();
        //String rlt = FindAndReplaceinString.findReplaceString();
        //int[][] rlt = InsertInterval.insert();
        //int rlt = TimeNeededtoInformAllEmployees.numOfMinutes();
        //NumberofGoodWaystoSplitaString.numSplits();
        //ReverseWordsinaString.reverseWords();
        //GroupAnagrams.groupAnagrams();
        //ReconstructItinerary.findItinerary();
        //BoundaryofBinaryTree.boundaryOfBinaryTree();
        //LongestSubstringWithoutRepeatingCharacters.lengthOfLongestSubstring();
        //int value = MaximumErasureValue.maximumUniqueSubarray();
        //boolean rlt = RectangleOverlap.isRectangleOverlap();
        //ShortestWordDistance.shortestDistance();
        //int rlt = MaximumLengthofaConcatenatedStringwithUniqueCharacters.maxLength();
        //PopulatingNextRightPointersinEachNode pnrp = new PopulatingNextRightPointersinEachNode();
        //pnrp.connect();
        //MinimumDeletionCosttoAvoidRepeatingLetters m = new MinimumDeletionCosttoAvoidRepeatingLetters();
        //int val = m.minCost();
        //MinimumDeletionstoMakeCharacterFrequenciesUnique m = new MinimumDeletionstoMakeCharacterFrequenciesUnique();
        //int valu = m.minDeletions();
        //ReplaceAllMarktoAvoidConsecutiveRepeatingCharacters r = new ReplaceAllMarktoAvoidConsecutiveRepeatingCharacters();
        //r.modifyString();
        //PartitionArrayintoDisjointIntervals p = new PartitionArrayintoDisjointIntervals();
        //int rlt = p.partitionDisjoint();
        //MergeIntervals m = new MergeIntervals();
        //m.merge();
        //LongestConsecutiveSequence l = new LongestConsecutiveSequence();
        //int val = l.longestConsecutive();
        //MaximalNetworkRank m = new MaximalNetworkRank();
        //m.maximalNetworkRank();
        //LargestNumber l = new LargestNumber();
        //String rlt = l.largestNumber();
        //LonelyPixelI l = new LonelyPixelI();
        //l.findLonelyPixel();
        //MinimumDeletionCosttoAvoidRepeatingLetters m = new MinimumDeletionCosttoAvoidRepeatingLetters();
        //m.minCost();
        //FlipStringtoMonotoneIncreasing f = new FlipStringtoMonotoneIncreasing();
        ///f.minFlipsMonoIncr("00110");
        //int arr[] = {-2, -2, 1, -2, -1, 2};
        //ArrayofDoubledPairs a = new ArrayofDoubledPairs();
        //boolean rlt = a.canReorderDoubled(arr);
        //SetMatrixZeroes s = new SetMatrixZeroes();
        //int matrix[][] = {{0}};
        //s.setZeroes(matrix);
        //ArrayWithElementsNotEqualtoAverageofNeighbors a = new ArrayWithElementsNotEqualtoAverageofNeighbors();
        //int nums[] = {6, 2, 0, 9, 7};
        //a.rearrangeArray(nums);
        //MinimumWindowSubstring m = new MinimumWindowSubstring();
        //String s = m.minWindow("ADOBECODEBANC", "ABC");
        // //DecodeWays d = new DecodeWays();
        //d.numDecodings("1116");
        /*TreeNode root = new TreeNode(1);
        //root.left = new TreeNode(2);
        root.right = new TreeNode(2);
        root.right.left = new TreeNode(3);
        root.right.right = new TreeNode(4);
        root.right.right.left = new TreeNode(5);
        root.right.right.right = new TreeNode(6);
        MaximumProductofSplittedBinaryTree m = new MaximumProductofSplittedBinaryTree();
        m.maxProduct(root);*/
        //MaximumMatrixSum m = new MaximumMatrixSum();
        //int[][] data = {{-10, -10, -10}, {-10, -10, -10}, {-10, -10, -10}};
        //lon   g val = m.maxMatrixSum(data);
        //FindUniqueBinaryString f = new FindUniqueBinaryString();
        //String[] s = {"01", "10"};
        //String r = f.findDifferentBinaryString(s);
        /*MinimizetheDifferenceBetweenTargetandChosenElements m = new MinimizetheDifferenceBetweenTargetandChosenElements();
        int[][] mat = { {10,3,7,7,9,6,9,8,9,5},
                        {1,1,6,8,6,7,7,9,3,9},
                        {3,4,4,1,3,6,3,3,9,9},
                        {6,9,9,3,8,7,9,6,10,6} };
        int val = m.minimizeTheDifference(mat, 5);*/

    //hard
        //FirstMissingPositive.firstMissingPositive();
        //SerializeandDeserializeNaryTree s = new SerializeandDeserializeNaryTree();
        //String de = s.serialize();
        //s.deserialize(de);
        //RemoveBoxes r = new RemoveBoxes();
        ///int boxes[] = {1, 3, 2, 2, 2, 3, 4, 3, 1};
        //r.removeBoxes(boxes);
        //GraphValidTree g = new GraphValidTree();
        //int[][] edges = {{0, 1}, {1, 2}, {2, 3}, {1, 3}, {1, 4}};
        ////int[][] edges = {{0, 1}, {0, 2}, {0, 3},{1, 4}};
        //boolean rlt = g.validTree(5, edges);

        System.out.println("============ end ============");
    }
}
